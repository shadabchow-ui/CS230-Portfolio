CS 230 Module Eight Journal
The Gaming Room: Client and Requirements

The Gaming Room wanted to evolve their Android-only game, Draw It or Lose It, into a cross-platform web-based application. Their requirements included supporting multiple teams and players, ensuring unique identifiers for games and teams, enabling timed multiplayer rounds, and ensuring secure, scalable access across platforms such as Windows, macOS, Linux, and mobile devices
.

What I Did Well

In the software design document, I feel I did particularly well at clearly outlining the design constraints and recommendations. I analyzed the trade-offs between operating platforms and justified why Linux should be the preferred server-side environment due to its stability, scalability, and cost-effectiveness.

Helpful Parts of the Process

Working through the design document was helpful because it forced me to carefully structure my thoughts before coding. By documenting architectural decisions, operating system evaluations, and constraints, I was able to anticipate challenges and plan strategies to handle scalability, memory management, and distributed systems.

What I Would Revise

If I were to revise one part of my work, I would expand the domain model and UML discussion to provide clearer explanations of the object-oriented design principles being applied. More detailed diagrams and examples of how principles like inheritance and encapsulation support the requirements would improve the clarity of the document.

Considering User Needs

I interpreted user needs by prioritizing scalability, usability, and security. For example, ensuring that game sessions had unique identifiers directly supported the need for smooth user experience without conflicts. It is important to focus on user needs because software only succeeds when it aligns with how real users interact with it.

Approach to Design

My approach to software design was systematic: analyze the requirements, evaluate platform trade-offs, identify design patterns like Singleton and Iterator, and then recommend the architecture best suited for the client. In the future, I would continue to use this approach, but I would also integrate iterative prototyping and user feedback earlier to validate assumptions before full implementation.
